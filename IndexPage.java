package simpledb;

import java.util.*;
import java.io.*;

/**
 * Index Page stores a bucket of IndexFile and implements the
 * Page interface that is used by BufferPool.
 *
 *
 * @see IndexFile
 * @see BufferPool
 */
public class IndexPage implements Page {

	public final static int META_OVERFLOW_LENGTH = 4;	//First 4 bytes of the page (storing pgno of the next overflow page in chain)
														//NOTE: You might NOT need this one, based on your index design and also the exact structure
														//		you are selecting
    boolean dirty = false;
    TransactionId dirtier = null;
    IndexPageId pid;
    TupleDesc td;
    int nextPage;
    Tuple tuples[];
    byte header[];
    int numSlots;
    ArrayList<Tuple> indices = new ArrayList<Tuple>();
    //You may need to define new attribute for this class based on your design



    /**
     * Constructor.
     * Construct the IndexPage from a set of bytes of data read
     * from disk.
     * The format of an IndexPage is
     * a 32-bit overflowPgnu plus a set of 32-bit header words indicating the
     * slot of the page that are in use, and plus (BufferPool.PAGE_SIZE/tuple
     * size) tuple slots, where tuple size is the size of tuples (index entries) in this
     * database table
     * The number of 32-bitheader words is equal to:
     * (no. tuple slots / 32) + 1
     */
    public IndexPage(IndexPageId id, byte[] data) throws IOException {
    	//Some code goes here
    	this.pid = id;
        this.numSlots = maxNumTuples();
        this.td = Database.getCatalog().getTupleDesc(id.getTableId());
        DataInputStream dis = new DataInputStream(new ByteArrayInputStream(data));

        // read the overflow page number
        nextPage = dis.readInt();
        
        // allocate and read the header slots of this page
        header = new byte[(int)Math.ceil(numSlots/8.0)];
        for (int i=0; i<header.length; i++) 
            header[i] = dis.readByte();
        
        try{
            // allocate and read the actual records of this page
            tuples = new Tuple[numSlots];
            for (int i=0; i<tuples.length; i++)
                tuples[i] = readNextTuple(dis,i);
            	
        }catch(NoSuchElementException e){
            e.printStackTrace();
        }
        dis.close();
        
        for(int i = 0; i<tuples.length; i++){
        	if (getSlot(i))
        		indices.add(tuples[i]);
        }
    }	

    private int maxNumTuples() {
        return (int) Math.floor((BufferPool.PAGE_SIZE*8) / (Database.getCatalog().getTupleDesc(pid.getTableId()).getSize()* 8 + 1));
    }
    
    /**
     * Suck up tuples from the source file.
     */
    private Tuple readNextTuple(DataInputStream dis, int slotId) throws NoSuchElementException {
        // if associated bit is not set, read forward to the next tuple, and
        // return null.
        if (!getSlot(slotId)) {
            for (int i=0; i<td.getSize(); i++) {
                try {
                    dis.readByte();
                } catch (IOException e) {
                    throw new NoSuchElementException("error reading empty tuple");
                }
            }
            return null;
        }

        // read fields in the tuple
        Tuple t = new Tuple(td);
        RecordId rid = new RecordId(pid, slotId);
        t.setRecordId(rid);
        try {
            for (int j=0; j<td.numFields(); j++) {
                Field f = td.getType(j).parse(dis);
                t.setField(j, f);
            }
        } catch (java.text.ParseException e) {
            e.printStackTrace();
            throw new NoSuchElementException("parsing error!");
        }

        return t;
    }
    
    /**
     * setting the value for pgnu of the next overflow page in chain for this page
     */
    public void setOverflowPageNum(int p) throws DbException{
    	//Some code goes here
    	nextPage = p;
    }

    /**
     * getting the value of next overflow pgnu
     */
    public int getOverflowPgnu(){
    	//Some code goes here
    	return nextPage;
    }

    /**
     * Needed for recovery - NOT REQUIRED FOR CS222
     */
    public void setBeforeImage() {
    	//Not needed for phase 2 (CS222 @ UCI can ignore it)
    }

    /**
     * @return the PageId associated with this page.
     */
    public IndexPageId getId() {
    	//Some code goes here
        return pid;
    }

    /**
     * Generates a byte array representing the contents of this page.
     * Used to serialize this page to disk.
     * <p>
     * The invariant here is that it should be possible to pass the byte array
     * generated by getPageData to the IndexPage constructor and have
     * it produce an identical IndexPage object.
     *
     * @see #IndexPage
     * @return A byte array correspond to the bytes of this page.
     */
    public byte[] getPageData() {
    	//Some code goes here
    	int len = BufferPool.PAGE_SIZE;
        ByteArrayOutputStream baos = new ByteArrayOutputStream(len);
        DataOutputStream dos = new DataOutputStream(baos);

        // create the pgno of the next overflow page
        try {
        	dos.writeInt(nextPage);
        } catch(IOException e) {
        	e.printStackTrace();
        }
        
        // create the header of the page
        for (int i=0; i<header.length; i++) {
            try {
                dos.writeByte(header[i]);
            } catch (IOException e) {
                // this really shouldn't happen
                e.printStackTrace();
            }
        }

        // create the tuples
        for (int i=0; i<tuples.length; i++) {

            // empty slot
            if (!getSlot(i)) {
                for (int j=0; j<td.getSize(); j++) {
                    try {
                        dos.writeByte(0);
                    } catch (IOException e) {
                        e.printStackTrace();
                    }

                }
                continue;
            }

            // non-empty slot
            for (int j=0; j<td.numFields(); j++) {
                Field f = tuples[i].getField(j);
                try {
                    f.serialize(dos);

                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }

        // padding
        int zerolen = BufferPool.PAGE_SIZE - (header.length + td.getSize() * tuples.length); //- numSlots * td.getSize();
        byte[] zeroes = new byte[zerolen];
        try {
            dos.write(zeroes, 0, zerolen);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            dos.flush();
        } catch (IOException e) {
            e.printStackTrace();
        }

        return baos.toByteArray();
    }

    /** Return a view of this page before it was modified
        -- used by recovery */
    public IndexPage getBeforeImage(){
        //Not needed for phase 2 (CS222 @ UCI can ignore it)
        return null;
    }



    /**
     * @return an iterator over all tuples (index entries) on this page.
     */
    public Iterator<Tuple> iterator() {
    	//Some code goes here
        return indices.iterator();
    }

    /**
     * Updates the tid of the transaction that makes this page dirty
     */
    public void markDirty(boolean dirty, TransactionId tid){
            this.dirty = dirty;
            if (dirty) this.dirtier = tid;
    }

    /**
     * Returns the tid of the dirtier transaction  if the page is dirty
     */
    public TransactionId isDirty() {
            if (this.dirty)
                return this.dirtier;
            else
                return null;
    }

    /**
     * Adds the specified tuple (index entry) to the page.
     * @throws DbException if the page is full (no empty slots) or tupledesc
     * is mismatch.
     * @param t The tuple (index entry) to add.
     */
    public void addTuple(Tuple t) throws DbException {
    	//Some code goes here
    	if(!t.getTupleDesc().equals(td))
    		throw new DbException("Tuple Description does not match");
    	if(getNumEmptySlots() < 1)
    		throw new DbException("No empty slots on page");
    	boolean full = true;
    	int i = -1;
    	while(full && i < tuples.length){
    		i++;
    		full = getSlot(i);
    	}
    	if(i >= tuples.length)
    		throw new DbException("No empty slots on page");
    	RecordId rid = new RecordId(pid, i);
    	setSlot(i, true);
    	t.setRecordId(rid);
    	tuples[i] = t;
    	indices.add(i, t);
    }

    /**
     * Delete the specified tuple from the page.
     * @throws DbException if this tuple is not on this page, or tuple slot is
     * already empty.
     * @param t The tuple (index entry) to delete
     * @return true if tuple can be deleted
     */
    public boolean deleteTuple(Tuple t) throws DbException {
    	//Some code goes here
    	int temp = indices.indexOf(t);
    	if(temp == -1)
    		return false;
    	indices.remove(temp);
    	int num = 0;
    	int i = 0;
    	while(num<temp) {
    		if(getSlot(i))
    			num++;
    		i++;
    	}    		
    	tuples[num] = null;
    	t.setRecordId(null);
    	setSlot(num, false);
        return true;
    }

    /**
     * Reads the tuple stored at the specified slotId in this IndexPage
     *
     * @param slotId
     * @return tuple stored in slotId
     * @throws NoSuchElementException if there is no valid tuple stored in the specified slot in this page
     */
    private Tuple readNextTuple(int slotId) throws NoSuchElementException {
    	//Some code goes here
    	int location = 0;
        if(getSlot(slotId))
        	for(int i=0; i<slotId; i++)
        		if(getSlot(i))
        			location++;
    	return indices.get(location);
    }


    /**
     * Returns true if associated slot on this page is filled with a tuple.
     */
    public boolean getSlot(int i) {
    	//Some code goes here
    	int headerByteNum = i/8;
    	int headerBitNum = (i-headerByteNum*8);
    	if(headerByteNum >= header.length)
    		return false;
        if( (header[headerByteNum]>>headerBitNum )%2 == 0){
        	return false;
        }
        return true;
    }


    /**
     * Abstraction to fill a slot on this page.
     */
    private void setSlot(int i, boolean value) {
    	//Some code goes here
    	int headerByteNum = i/8;
    	int headerBitNum = (i-headerByteNum*8);
    	if(value)
    		header[headerByteNum] |= (1 << headerBitNum);
    	else
    		header[headerByteNum] &= ~(1 << headerBitNum);
    }


    /**
     * Returns the number of empty slots on this page.
     */
    public int getNumEmptySlots() {
    	//Some code goes here
        return numSlots - getNumTuples();
    }
    
    public int getFirstEmptySlot() {
//    	boolean found = false;
//    	int i = -1;
//    	if(getNumEmptySlots()==0)
//    		return i;
//    	while(!found && i < tuples.length){
//    		i++;
//    		found = !getSlot(i);
//    	}
//    	if(i == tuples.length)
//    		return -1;
//    	return i;
    	
    	int i =0; 
    	while(i<tuples.length){
    		if(!getSlot(i)){
    			return i;
    		}
    		i++;
    	}
    	return -1;
    }
    
    public int getNumTuples() {
    	int tot = 0;
        for(int i=0;i<header.length;i++)
        	for(int j=0; j<8; j++)
        		if(getSlot(i*8+j))
        			tot++;
        return tot;
    }

    /**
     * Static method to generate a byte array corresponding to an empty
     * IndexPage.
     * Used to add new, empty pages to the index file.
     *
     * @param tableid The id of the table that this empty page will belong to.
     * @return The returned ByteArray.
     */
    public static byte[] createEmptyIndexPageData(int tableid) {
    	//Some code goes here
    	int len = BufferPool.PAGE_SIZE;
        return new byte[len];
    }

    // protected method used by the iterator to get the ith tuple
    // out of this page
    Tuple getTuple(int i) throws NoSuchElementException {
    	//Some code goes here
        return indices.get(i);
    }

}