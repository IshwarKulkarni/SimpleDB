package simpledb;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.NoSuchElementException;

import sun.net.www.content.image.jpeg;

/**
 * The Join operator implements the relational join operation.
 */
public class Join extends AbstractDbIterator {

	private JoinPredicate pred;
	private DbIterator child1;
	private DbIterator child2;
	private boolean generatedJoin;

	private TupleDesc joinTupleTd;
	private TupleDesc td1;
	private TupleDesc td2;
	private boolean bothOpen;
	private boolean generated;
	private ArrayList<Tuple> joinList = new ArrayList<Tuple>();
	private int joinListPtr = 0;
	private ListIterator<Tuple> iter;
	JoinIterator ji;

	/**
	 * Constructor. Accepts to children to join and the predicate to join them
	 * on
	 * 
	 * @param p
	 *            The predicate to use to join the children
	 * @param child1
	 *            Iterator for the left(outer) relation to join
	 * @param child2
	 *            Iterator for the right(inner) relation to join
	 */
	public Join(JoinPredicate p, DbIterator child1, DbIterator child2) {
		this.pred = p;
		this.child1 = child1;
		this.child2 = child2;
		generatedJoin = false;

		td1 = child1.getTupleDesc();
		td2 = child2.getTupleDesc();
		Type[] complete = new Type[td1.numFields() + td2.numFields()];
		int i = 0;
		for (; i < td1.numFields(); i++) {
			complete[i] = td1.getType(i);
		}
		for (int j=0; j < td2.numFields(); j++) {

			complete[i++] = td2.getType(j);
		}
		generated = false;
		joinTupleTd = new TupleDesc(complete);
		try {
			generateJoin();
		} catch (NoSuchElementException e) {
			
			e.printStackTrace();
		} catch (DbException e) {
			
			e.printStackTrace();
		} catch (TransactionAbortedException e) {
			
			e.printStackTrace();
		}
		 ji = new JoinIterator(joinList);
	}

	/**
	 * @see simpledb.TupleDesc#combine(TupleDesc, TupleDesc) for possible
	 *      implementation logic.
	 */
	public TupleDesc getTupleDesc() {
		// some code goes here
		return TupleDesc.combine(child1.getTupleDesc(), child2.getTupleDesc());

	}

	public void open() throws DbException, NoSuchElementException,
			TransactionAbortedException {
		ji.open();
		bothOpen = true;
	}

	public void close() {
		ji.close();
		bothOpen = false;
	}

	public void rewind() throws DbException, TransactionAbortedException {
		child1.rewind();
		child2.rewind();
		ji.rewind();
		joinListPtr = 0;
	}

	/**
	 * Returns the next tuple generated by the join, or null if there are no
	 * more tuples. Logically, this is the next tuple in r1 cross r2 that
	 * satisfies the join predicate. There are many possible implementations;
	 * the simplest is a nested loops join.
	 * <p>
	 * Note that the tuples returned from this particular implementation of Join
	 * are simply the concatenation of joining tuples from the left and right
	 * relation. Therefore, if an equality predicate is used there will be two
	 * copies of the join attribute in the results. (Removing such duplicate
	 * columns can be done with an additional projection operator if needed.)
	 * <p>
	 * For example, if one tuple is {1,2,3} and the other tuple is {1,5,6},
	 * joined on equality of the first column, then this returns {1,2,3,1,5,6}.
	 * 
	 * @return The next matching tuple.
	 * @see JoinPredicate#filter
	 */
	protected Tuple readNext() throws TransactionAbortedException, DbException {
		if (ji.hasNext())
			return ji.next();
		return null;
	}

	private void generateJoin() throws NoSuchElementException, DbException,
			TransactionAbortedException {

		Tuple t1;
		Tuple t2;

		child1.rewind();
		while (child1.hasNext()) {
			t1 = child1.next();
			child2.rewind();
			while (child2.hasNext()) {
				t2 = child2.next();
				if (pred.filter(t1, t2)) {
					joinList.add(concatTuples(t1, t2));
				}
			}

		}

//		for (int i = 0; i < joinList.size(); i++) {
//			System.out.println(joinList.get(i));
//		}
//		System.out.println("end of list");
		iter = joinList.listIterator();
		generated = true;
	}

	private Tuple concatTuples(Tuple left, Tuple right) {

		Tuple local = new Tuple(joinTupleTd);

		int l = 0;
		for (int i = 0; i < td1.numFields(); i++) {
			local.setField(l, left.getField(i));
			l++;
		}
		for (int i = 0; i < td2.numFields(); i++) {
			local.setField(l, right.getField(i));
			l++;
		}

		return local;
	}

	private class JoinIterator implements DbFileIterator {

		Iterator<Tuple> tupleItr;
		ArrayList<Tuple> tupleList = new ArrayList<Tuple>();

		public JoinIterator(ArrayList<Tuple> tupleList) {
			this.tupleList = tupleList;
		}

		@Override
		public void close() {
			tupleItr = null;
		}

		@Override
		public boolean hasNext() throws DbException,
				TransactionAbortedException {
			if (tupleItr != null) {
				return tupleItr.hasNext();
			}
			return false;
		}

		@Override
		public Tuple next() throws DbException, TransactionAbortedException,
				NoSuchElementException {
			if (tupleItr != null) {
				return tupleItr.next();
			}
			throw new NoSuchElementException();
		}

		@Override
		public void open() throws DbException, TransactionAbortedException {
			this.tupleItr = this.tupleList.iterator();

		}

		@Override
		public void rewind() throws DbException, TransactionAbortedException {
			this.close();
			this.open();
		}

	}

}
